import {
  property
} from "./chunk-2GVNILSI.js";
import {
  LitElement
} from "./chunk-VND65WS7.js";
import {
  __export
} from "./chunk-RURKGQD7.js";

// ../../node_modules/@calpoly/mustang/src/auth.ts
var auth_exports = {};
__export(auth_exports, {
  AuthenticatedUser: () => AuthenticatedUser,
  Provider: () => AuthProvider,
  User: () => APIUser,
  headers: () => authHeaders
});

// ../../node_modules/jwt-decode/build/esm/index.js
var InvalidTokenError = class extends Error {
};
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {
    let code = p.charCodeAt(0).toString(16).toUpperCase();
    if (code.length < 2) {
      code = "0" + code;
    }
    return "%" + code;
  }));
}
function base64UrlDecode(str) {
  let output = str.replace(/-/g, "+").replace(/_/g, "/");
  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += "==";
      break;
    case 3:
      output += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(output);
  } catch (err) {
    return atob(output);
  }
}
function jwtDecode(token, options) {
  if (typeof token !== "string") {
    throw new InvalidTokenError("Invalid token specified: must be a string");
  }
  options || (options = {});
  const pos = options.header === true ? 0 : 1;
  const part = token.split(".")[pos];
  if (typeof part !== "string") {
    throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
  }
  let decoded;
  try {
    decoded = base64UrlDecode(part);
  } catch (e) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);
  }
  try {
    return JSON.parse(decoded);
  } catch (e) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);
  }
}

// ../../node_modules/@calpoly/mustang/src/context.ts
var EVENT_PREFIX = "mu:context";
var CONTEXT_CHANGE_EVENT = `${EVENT_PREFIX}:change`;
var Context = class {
  _proxy;
  constructor(init, host) {
    this._proxy = createContext(init, host);
  }
  get value() {
    return this._proxy;
  }
  set value(next) {
    Object.assign(this._proxy, next);
  }
  apply(mapFn) {
    this.value = mapFn(this.value);
  }
};
var Provider = class extends HTMLElement {
  context;
  constructor(init) {
    super();
    console.log("Constructing context provider", this);
    this.context = new Context(init, this);
    this.style.display = "contents";
  }
  attach(observer) {
    this.addEventListener(CONTEXT_CHANGE_EVENT, observer);
    return observer;
  }
  detach(observer) {
    this.removeEventListener(CONTEXT_CHANGE_EVENT, observer);
  }
};
function createContext(root, eventTarget) {
  let proxy = new Proxy(root, {
    get: (target, prop, receiver) => {
      if (prop === "then") {
        return void 0;
      }
      const value = Reflect.get(target, prop, receiver);
      console.log(
        `Context['${prop}'] => ${JSON.stringify(value)}`
      );
      return value;
    },
    set: (target, prop, newValue, receiver) => {
      const oldValue = root[prop];
      console.log(
        `Context['${prop.toString()}'] <= ${JSON.stringify(
          newValue
        )}; was ${JSON.stringify(oldValue)}`
      );
      const didSet = Reflect.set(
        target,
        prop,
        newValue,
        receiver
      );
      if (didSet) {
        let evt = new CustomEvent(CONTEXT_CHANGE_EVENT, {
          bubbles: true,
          cancelable: true,
          composed: true
        });
        Object.assign(evt, {
          property: prop,
          oldValue,
          value: newValue
        });
        eventTarget.dispatchEvent(evt);
      } else {
        console.log(
          `Context['${prop}] was not set to ${newValue}`
        );
      }
      return didSet;
    }
  });
  return proxy;
}
function whenProviderReady(consumer, contextLabel) {
  const provider = closestProvider(
    contextLabel,
    consumer
  );
  return new Promise((resolve, reject) => {
    if (provider) {
      const name = provider.localName;
      customElements.whenDefined(name).then(() => resolve(provider));
    } else {
      reject({
        context: contextLabel,
        reason: `No provider for this context "${contextLabel}:`
      });
    }
  });
}
function closestProvider(contextLabel, el) {
  const selector = `[provides="${contextLabel}"]`;
  if (!el || el === document.getRootNode())
    return void 0;
  const closest = el.closest(selector);
  if (closest)
    return closest;
  const root = el.getRootNode();
  if (root instanceof ShadowRoot)
    return closestProvider(contextLabel, root.host);
  return void 0;
}

// ../../node_modules/@calpoly/mustang/src/message.ts
var message_exports = {};
__export(message_exports, {
  Dispatch: () => Dispatch,
  dispatcher: () => dispatcher
});
var Dispatch = class extends CustomEvent {
  constructor(msg, eventType = "mu:message") {
    super(eventType, {
      bubbles: true,
      composed: true,
      detail: msg
    });
  }
};
function dispatcher(eventType) {
  return (target, ...msg) => target.dispatchEvent(new Dispatch(msg, eventType));
}

// ../../node_modules/@calpoly/mustang/src/service.ts
var Service = class {
  _context;
  _update;
  _eventType;
  _running = false;
  _pending = [];
  attach(host) {
    host.addEventListener(this._eventType, (ev) => {
      ev.stopPropagation();
      const message = ev.detail;
      this.consume(message);
    });
  }
  start() {
    if (!this._running) {
      console.log(`Starting ${this._eventType} service`);
      this._running = true;
      this._pending.forEach((msg) => this.process(msg));
    }
  }
  constructor(update, context, eventType = "service:message") {
    this._context = context;
    this._update = update;
    this._eventType = eventType;
  }
  apply(fn) {
    this._context.apply(fn);
  }
  consume(message) {
    if (this._running) {
      this.process(message);
    } else {
      console.log(
        `Queueing ${this._eventType} message`,
        message
      );
      this._pending.push(message);
    }
  }
  process(message) {
    console.log(
      `Processing ${this._eventType} message`,
      message
    );
    const command = this._update(
      message,
      this.apply.bind(this)
    );
    if (command)
      command(this._context.value);
  }
};

// ../../node_modules/@calpoly/mustang/src/update.ts
var update_exports = {};
__export(update_exports, {
  identity: () => identity,
  replace: () => replace
});
function identity(model) {
  return model;
}
function replace(replacements) {
  return (model) => ({ ...model, ...replacements });
}

// ../../node_modules/@calpoly/mustang/src/auth.ts
var TOKEN_KEY = "mu:auth:jwt";
var AuthService = class _AuthService extends Service {
  static EVENT_TYPE = "auth:message";
  _redirectForLogin;
  constructor(context, redirectForLogin) {
    super(
      (m, a) => this.update(m, a),
      context,
      _AuthService.EVENT_TYPE
    );
    this._redirectForLogin = redirectForLogin;
  }
  update(message, apply) {
    switch (message[0]) {
      case "auth/signin":
        const { token, redirect } = message[1];
        apply(signIn(token));
        return redirection(redirect);
      case "auth/signout":
        apply(signOut());
        return redirection(this._redirectForLogin);
      case "auth/redirect":
        apply(signOut());
        return redirection(this._redirectForLogin, {
          next: window.location.href
        });
      default:
        const unhandled = message[0];
        throw new Error(
          `Unhandled Auth message "${unhandled}"`
        );
    }
  }
  static dispatch = dispatcher(_AuthService.EVENT_TYPE);
};
function redirection(redirect, query = {}) {
  if (!redirect)
    return void 0;
  const base = window.location.href;
  const target = new URL(redirect, base);
  Object.entries(query).forEach(
    ([k, v]) => target.searchParams.set(k, v)
  );
  return () => {
    console.log("Redirecting to ", redirect);
    window.location.assign(target);
  };
}
var AuthProvider = class extends Provider {
  get redirect() {
    return this.getAttribute("redirect") || void 0;
  }
  constructor() {
    super({
      user: AuthenticatedUser.authenticateFromLocalStorage()
    });
  }
  connectedCallback() {
    const service = new AuthService(
      this.context,
      this.redirect
    );
    service.attach(this);
  }
};
var APIUser = class {
  authenticated = false;
  username = "anonymous";
  static deauthenticate(user) {
    user.authenticated = false;
    user.username = "anonymous";
    localStorage.removeItem(TOKEN_KEY);
    return user;
  }
};
var AuthenticatedUser = class _AuthenticatedUser extends APIUser {
  token;
  constructor(token) {
    super();
    const jsonPayload = jwtDecode(token);
    console.log("Token payload", jsonPayload);
    this.token = token;
    this.authenticated = true;
    this.username = jsonPayload.username;
  }
  static authenticate(token) {
    const authenticatedUser = new _AuthenticatedUser(token);
    localStorage.setItem(TOKEN_KEY, token);
    return authenticatedUser;
  }
  static authenticateFromLocalStorage() {
    const priorToken = localStorage.getItem(TOKEN_KEY);
    return priorToken ? _AuthenticatedUser.authenticate(priorToken) : new APIUser();
  }
};
function signIn(token) {
  return replace({
    user: AuthenticatedUser.authenticate(token),
    token
  });
}
function signOut() {
  return (model) => {
    const oldUser = model.user;
    return {
      user: oldUser && oldUser.authenticated ? APIUser.deauthenticate(oldUser) : oldUser,
      token: ""
    };
  };
}
function authHeaders(user) {
  if (user.authenticated) {
    const authUser = user;
    return {
      Authorization: `Bearer ${authUser.token || "NO_TOKEN"}`
    };
  } else {
    return {};
  }
}

// ../../node_modules/@calpoly/mustang/src/html.ts
var parser = new DOMParser();
function html(template, ...params) {
  const htmlString = template.map((s, i) => i ? [params[i - 1], s] : [s]).flat().join("");
  const doc = parser.parseFromString(htmlString, "text/html");
  const collection = doc.head.childElementCount ? doc.head.children : doc.body.children;
  const fragment = new DocumentFragment();
  fragment.replaceChildren(...collection);
  return fragment;
}
function shadow(fragment) {
  const first = fragment.firstElementChild;
  const template = first && first.tagName === "TEMPLATE" ? first : void 0;
  return { attach };
  function attach(el, options = { mode: "open" }) {
    const shadow2 = el.attachShadow(options);
    if (template)
      shadow2.appendChild(template.content.cloneNode(true));
    return shadow2;
  }
}

// ../../node_modules/@calpoly/mustang/src/components/drop-down.ts
var DropdownElement = class _DropdownElement extends HTMLElement {
  static template = html`<template>
    <slot name="actuator"><button> Menu </button></slot>
    <div id="panel">
      <slot></slot>
    </div>

    <style>
      :host {
        position: relative;
      }
      #is-shown {
        display: none;
      }
      #panel {
        display: none;

        position: absolute;
        right: 0;
        margin-top: var(--size-spacing-small);
        width: max-content;
        padding: var(--size-spacing-small);
        border-radius: var(--size-radius-small);
        background: var(--color-background-card);
        color: var(--color-text);
        box-shadow: var(--shadow-popover);
      }
      :host([open]) #panel {
        display: block;
      }
    </style>
  </template>`;
  constructor() {
    super();
    shadow(_DropdownElement.template).attach(this);
    if (this.shadowRoot) {
      const actuator = this.shadowRoot.querySelector(
        "slot[name='actuator']"
      );
      if (actuator)
        actuator.addEventListener("click", () => this.toggle());
    }
  }
  toggle() {
    if (this.hasAttribute("open"))
      this.removeAttribute("open");
    else
      this.setAttribute("open", "open");
  }
};

// ../../node_modules/@calpoly/mustang/src/define.ts
function define(defns) {
  Object.entries(defns).map(([k, v]) => {
    if (!customElements.get(k))
      customElements.define(k, v);
  });
  return customElements;
}

// ../../node_modules/@calpoly/mustang/src/event.ts
var event_exports = {};
__export(event_exports, {
  relay: () => relay
});
function relay(event, customType, detail) {
  const relay2 = event.currentTarget;
  const customEvent = new CustomEvent(customType, {
    bubbles: true,
    composed: true,
    detail
  });
  console.log(
    `Relaying event from ${event.type}:`,
    customEvent
  );
  relay2.dispatchEvent(customEvent);
  event.stopPropagation();
}

// ../../node_modules/@calpoly/mustang/src/observer.ts
var Observer = class {
  _target;
  _contextLabel;
  _provider;
  _effects = [];
  constructor(target, contextLabel) {
    this._target = target;
    this._contextLabel = contextLabel;
  }
  observe(fn = void 0) {
    return new Promise((resolve, _) => {
      if (this._provider) {
        const effect = new Effect(this._provider, fn);
        this._effects.push(effect);
        resolve(effect);
      } else {
        whenProviderReady(this._target, this._contextLabel).then((provider) => {
          const effect = new Effect(provider, fn);
          this._provider = provider;
          this._effects.push(effect);
          provider.attach(
            (ev) => this._handleChange(ev)
          );
          resolve(effect);
        }).catch(
          (err) => console.log(
            `Observer ${this._contextLabel} failed to locate a provider`,
            err
          )
        );
      }
    });
  }
  _handleChange(ev) {
    console.log(
      "Received change event for observers",
      ev,
      this._effects
    );
    this._effects.forEach((obs) => obs.runEffect());
  }
};
var Effect = class {
  _provider;
  _effectFn;
  constructor(observable, fn) {
    this._provider = observable;
    if (fn)
      this.setEffect(fn);
  }
  get context() {
    return this._provider.context;
  }
  get value() {
    return this.context.value;
  }
  setEffect(fn) {
    this._effectFn = fn;
    this.runEffect();
  }
  runEffect() {
    if (this._effectFn) {
      this._effectFn(this.context.value);
    }
  }
};

// ../../node_modules/@calpoly/mustang/src/rest.ts
var rest_exports = {};
__export(rest_exports, {
  FormElement: () => FormElement,
  fetchData: () => fetchData
});
var FormElement = class _FormElement extends HTMLElement {
  static observedAttributes = ["src", "new"];
  get src() {
    return this.getAttribute("src");
  }
  get isNew() {
    return this.hasAttribute("new");
  }
  static template = html`
    <template>
      <form autocomplete="off">
        <slot></slot>
        <slot><button type="submit">Submit</button></slot>
      </form>
      <slot name="delete"></slot>
      <style>
        form {
          display: grid;
          gap: var(--size-spacing-medium);
          grid-template-columns: [start] 1fr [label] 1fr [input] 3fr 1fr [end];
        }
        ::slotted(label) {
          display: grid;
          grid-column: label / end;
          grid-template-columns: subgrid;
          gap: var(--size-spacing-medium);
        }
        button[type="submit"] {
          grid-column: input;
          justify-self: start;
        }
      </style>
    </template>
  `;
  get form() {
    return this.shadowRoot?.querySelector("form");
  }
  _state = {};
  _user = new APIUser();
  constructor() {
    super();
    shadow(_FormElement.template).attach(this);
    if (this.form) {
      this.form.addEventListener("submit", (event) => {
        event.preventDefault();
        if (this.src) {
          console.log("Submitting form", this._state);
          const method = this.isNew ? "POST" : "PUT";
          const action = this.isNew ? "created" : "updated";
          const src = this.isNew ? this.src.replace(/[/][$]new$/, "") : this.src;
          submitForm(
            src,
            this._state,
            method,
            this.authorization
          ).then((json) => populateForm(json, this)).then((json) => {
            const customType = `mu-rest-form:${action}`;
            const event2 = new CustomEvent(customType, {
              bubbles: true,
              composed: true,
              detail: {
                method,
                [action]: json,
                url: src
              }
            });
            this.dispatchEvent(event2);
          });
        }
      });
    }
    this.addEventListener("change", (event) => {
      const target = event.target;
      if (target) {
        const name = target.name;
        const value = target.value;
        if (name)
          this._state[name] = value;
      }
    });
  }
  _authObserver = new Observer(
    this,
    "blazing:auth"
  );
  get authorization() {
    if (this._user?.authenticated) {
      const user = this._user;
      return { Authorization: `Bearer ${user.token}` };
    } else {
      return {};
    }
  }
  connectedCallback() {
    this._authObserver.observe(({ user }) => {
      if (user) {
        this._user = user;
        if (this.src) {
          fetchData(this.src, this.authorization).then(
            (json) => {
              this._state = json;
              populateForm(json, this);
            }
          );
        }
      }
    });
  }
  attributeChangedCallback(name, oldValue, newValue) {
    switch (name) {
      case "src":
        if (this.src && newValue && newValue !== oldValue && !this.isNew) {
          fetchData(this.src, this.authorization).then(
            (json) => {
              this._state = json;
              populateForm(json, this);
            }
          );
        }
        break;
      case "new":
        if (newValue) {
          this._state = {};
          populateForm({}, this);
        }
        break;
    }
  }
};
function fetchData(src, authorization) {
  return fetch(src, { headers: authorization }).then((response) => {
    if (response.status !== 200) {
      throw `Status: ${response.status}`;
    }
    return response.json();
  }).catch(
    (error) => console.log(`Failed to load form from ${src}:`, error)
  );
}
function populateForm(json, formBody) {
  const entries = Object.entries(json);
  for (const [key, val] of entries) {
    const el = formBody.querySelector(`[name="${key}"]`);
    if (el) {
      const input = el;
      switch (input.type) {
        case "checkbox":
          const checkbox = input;
          checkbox.checked = Boolean(val);
          break;
        default:
          input.value = val;
          break;
      }
    }
  }
  return json;
}
function submitForm(src, json, method = "PUT", authorization = {}) {
  return fetch(src, {
    method,
    headers: {
      "Content-Type": "application/json",
      ...authorization
    },
    body: JSON.stringify(json)
  }).then((res) => {
    if (res.status != 200 && res.status != 201)
      throw `Form submission failed: Status ${res.status}`;
    return res.json();
  }).catch((err) => console.log("Error submitting form:", err));
}

// ../../node_modules/@calpoly/mustang/src/store.ts
var store_exports = {};
__export(store_exports, {
  Provider: () => StoreProvider,
  Service: () => StoreService
});
var StoreService = class _StoreService extends Service {
  static EVENT_TYPE = "mu:message";
  constructor(context, updateFn) {
    super(updateFn, context, _StoreService.EVENT_TYPE);
  }
};
var StoreProvider = class extends Provider {
  _updateFn;
  _authObserver;
  _user = new APIUser();
  constructor(update, init, authContext) {
    super(init);
    this._updateFn = update;
    this._authObserver = new Observer(
      this,
      authContext
    );
  }
  connectedCallback() {
    const service = new StoreService(
      this.context,
      (msg, apply) => this._updateFn(msg, apply, this._user)
    );
    service.attach(this);
    this._authObserver.observe(({ user }) => {
      console.log("Store got auth", user);
      if (user)
        this._user = user;
      service.start();
    });
  }
};

// ../../node_modules/@calpoly/mustang/src/view.ts
var View = class extends LitElement {
  _observer;
  _context;
  _lastModel;
  @property()
  get model() {
    this._lastModel = this._context ? this._context.value : {};
    return this._lastModel;
  }
  constructor(context) {
    super();
    this._observer = new Observer(this, context);
  }
  connectedCallback() {
    super.connectedCallback();
    this._observer?.observe().then((effect) => {
      console.log("View effect (initial)", effect);
      this._context = effect.context;
      effect.setEffect(() => {
        console.log("View effect", effect, this._context);
        if (this._context) {
          console.log("requesting update");
          this.requestUpdate();
        } else {
          throw "View context not ready for effect";
        }
      });
    });
  }
  dispatchMessage(msg, target = this) {
    const ev = new CustomEvent("mu:message", {
      bubbles: true,
      composed: true,
      detail: msg
    });
    target.dispatchEvent(ev);
  }
  ref(key) {
    return this.model ? this.model[key] : void 0;
  }
};
export {
  auth_exports as Auth,
  DropdownElement,
  Effect,
  event_exports as Events,
  message_exports as Message,
  Observer,
  rest_exports as Rest,
  store_exports as Store,
  update_exports as Update,
  View,
  define,
  html,
  shadow
};
//# sourceMappingURL=@calpoly_mustang.js.map
